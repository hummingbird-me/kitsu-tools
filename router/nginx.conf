server {
    listen 80;

    # Proxy settings
    resolver 127.0.0.11;
    proxy_redirect off;
    proxy_set_header Host $http_host;
    proxy_set_header X-Real_IP $remote_addr;
    proxy_set_header X-Forwarded_For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;

    # File serving
    sendfile on;
    include /etc/nginx/mime.types;

    # This nonsense is to force runtime (instead of boot-time) resolution of DNS
    # so that Docker containers can be swapped, while being functionally
    # equivalent to the following block:
    #
    #     location /api/ {
    #         proxy_pass http://server/;
    #     }
    #
    # It rewrites the path, stripping the prefix of the location block, so that
    # Rails doesn't have to be completely aware that it's nested under /api/.
    location ~* /api/(?<path>.*$) {
        set $upstream "http://server/api/";
        proxy_pass $upstream$path$is_args$args;
    }
    location ~* /api/system/(?<path>.*$) {
        set $upstream "http://server/";
        proxy_pass $upstream$path$is_args$args;
        client_max_body_size 10M;
    }
    location ~* /rails/(?<path>.*$) {
        set $upstream "http://server/rails/";
        proxy_pass $upstream$path$is_args$args;
    }
    location ~* /(?<path>.*$) {
        set $upstream "http://client/";
        proxy_pass $upstream$path$is_args$args;
    }
    location ^~ /system/ {
        root /srv/www/uploads/;
        try_files $uri @media;
    }
    location @media {
        rewrite ^/system(/.*)$ $1 break;
        proxy_set_header Host 'media.kitsu.io';
        proxy_pass https://media.kitsu.io;
    }
}
